%--------------------------------------------------------------------------
\chapter{\label{Appendix_HPC}
Research using High Performance Computing}
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
\section{\label{A:Comp_Env}Setting Up Computing Environment}
%--------------------------------------------------------------------------

% %%--------------------------------------------------------------------------
% %\subsection{Suggested Reading}
% %%--------------------------------------------------------------------------
% 
% %The online encyclopedia \href{http://www.wikipedia.org/}{wikipedia} 
% %has become an excellent resource for technical knowledge. 
% 
% %\href{http://en.wikipedia.org/wiki/Statistical_mechanics}
% %{Statistical Mechanics}/
% %\href{http://en.wikipedia.org/wiki/Condensed_matter}
% %{Condensed Matter}
% %\cite{ashcroft_solid_1976,mcquarrie_statistical_2000}
% 
% %\href{http://en.wikipedia.org/wiki/Phonon}
% %{Lattice Dynamics} with focus on the classical, quantum 
% %and thermodynamic properties of phonons.\cite{peierls_,ziman,
% %wallace_thermodynamics_1976,
% %srivastava_1990,dove_lattice_1993} 
% 
% %\href{http://en.wikipedia.org/wiki/Introduction_to_quantum_mechanics}{Introduction to quantum mechanics and quantum chemistry}
% %\cite{griffiths_introduction_1995} 
% %and more 
% %advanced topics on 
% %\href{https://en.wikipedia.org/wiki/Electron_configuration}
% %{Electron Strucutre} and 
% %\href{http://en.wikipedia.org/wiki/Density_functional_theory}
% %{Density Functional Theory}.
% %\cite{martin_electronic_2004} 
% 
% %Analytical methods for 
% %\href{http://en.wikipedia.org/wiki/Ordinary_differential_equations}
% %{ordinary} and 
% %\href{http://en.wikipedia.org/wiki/Partial_differential_equation}
% %{partial differential equations}, 
% %\href{http://en.wikipedia.org/wiki/Fourier_analysis}
% %{fourier} and 
% %\href{http://en.wikipedia.org/wiki/Statistics}
% %{statistical analysis},\cite{mcquarrie_mathematical_2003} 
% %and 
% %\href{http://en.wikipedia.org/wiki/Numerical_analysis}
% %{numerical analysis}.\cite{moin_fundamentals_2010} For example, 
% %the LJ MD code discussed in Section uses a  
% %\href{http://en.wikipedia.org/wiki/Verlet_integration}
% %{verlet integration method}. 

%--------------------------------------------------------------------------
\subsection{\label{A:Comp_Env:OS}Hardware and Operating System Choice}
%--------------------------------------------------------------------------

The choice of computing hardware determines which operating system(s) 
can be used. The three 
main choices for operating system are 
\href{http://en.wikipedia.org/wiki/Microsoft_Windows}{Windows}, 
\href{http://en.wikipedia.org/wiki/Mac_OS}{Apple OS}, and 
\href{http://en.wikipedia.org/wiki/Linux}{Linux}. Each 
operating system has limitations depending on the hardware it 
operates on.   
For example, Apple OS is primarily used on 
\href{http://en.wikipedia.org/wiki/Macintosh}{Apple hardware}.

The Linux operating system is based on unix, which is the  
\href{http://www.youtube.com/watch?v=7XTHdcmjenI}
{world's most widely used software}. 
Linux runs on systems ranging from 
\href{http://www.pcworld.com/article/250899/mobile_linux_its_not_just_android_anymore.html}
{cell phones} to the world's 
\href{http://www.zdnet.com/20-great-years-of-linux-and-supercomputers-7000018681/}
{largest supercomputers}. For personal computing use, the most widely 
used Linux version is \href{http://www.ubuntu.com/}{Ubuntu}.
It is well-documented with a large community-based discussion 
system. Apple OS is an adequate substitute as it is 
\href{https://en.wikipedia.org/wiki/Unix-like}{unix-like}.

There are many options for installing Ubuntu and the instructions 
can be found at 
\href{http://www.ubuntu.com/}{ubuntu.com}.
Ubuntu is certified on 
\href{http://www.ubuntu.com/certification/}
{PC's from many computer companies}. 
One company, \href{https://www.system76.com/}{system 76}, 
builds computers with Ubuntu pre-installed. I used the 
\href{https://www.system76.com/laptops/model/panp9}
{Pangolin Performance} for over a year of my Ph.D.  However, 
I recommend using the most-portable (i.e., lightest) and 
longest-battery life notebook available such as the 
\href{https://help.ubuntu.com/community/SamsungSeries9}
{Samsung Series 9}  
or \href{https://help.ubuntu.com/community/MacBookAir}{Macbook Air}. 
You will typically be using this notebook to access large computing 
clusters remotely, 
so there is a benefit of having portability and long 
battery life over computational power.  

%--------------------------------------------------------------------------
\subsection{\label{A:Comp_Env:Term}
Terminal, Commands, and Environment Variables}
%--------------------------------------------------------------------------

These instructions work best for the Ubuntu operating system, and will work 
well for other versions of Linux. Systems commands are executed by the 
system 
\href{https://help.ubuntu.com/community/UsingTheTerminal}{terminal}. 
The following Linux system commands have been used extensively throughout 
this work: sudo, cd, pwd, ls, export, echo, grep, sed, vi, cat, 
scp, ssh, which, nohup. 
There are many more Linux commands that are useful. More information can 
be obtained simply by google searching, i.e. 
\href{https://www.google.com/search?q=linux+sed}
{google: linux sed} 

\href{http://en.wikipedia.org/wiki/Environment_variable}{Environment variables}, 
such as 
\href{http://en.wikipedia.org/wiki/PATH_(variable)}{PATH}, 
can store the paths to installed programs and files. 
Here is how to determine what PATH is set to:
\begin{lstlisting}
$ echo $PATH
/opt/Datathief:/opt/VESTA-x86_64:/home/jason/phonopy/phonopy-1.1/bin:...
\end{lstlisting}
Permanent changes to environment variables can be made in the user's 
\href{https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html}
{.bashrc file}, which is typically located in the /home/user/ directory. 
The .bashrc file is a 
\href{http://www.ghacks.net/2009/04/16/linux-tips-view-hidden-files/}{hidden file} 
noted by its name starting with ".". 
Here is an example 
\href{https://gist.github.com/kparrish/6064111}{.bashrc} from 
\href{https://github.com/kparrish}{Kevin Parrish}. 
This file modifies environment variables such as 
\href{https://help.ubuntu.com/community/EnvironmentVariables}{PATH}  
when a bash terminal session is launched. Changes to environment 
variables are made when a new terminal session is started. 

Shell scripts are relatively low-level sets of system commands 
which can manipulate environment variables 
and the Linux operating system. 
\href{http://linuxcommand.org/wss0010.php}{Here is a simple tutorial} 
on writing shell scripts. 
\href{http://docs.python.org/2/library/os.html}
{Running Linux system commands in Python} can be an effective way of 
generating and manipulating many files with one script. Python 
is a more robust language than lower-level shell scripting. 
\href{https://github.com/ntpl/ntpy/blob/master/examples/thesis/run.lammps.py}
{Here is an example} that generates a series of shell scripts used to 
submit jobs on cluster resources (see next section). The Python script 
finds dummy variable names (SHELL$\_$NAME and PROC$\_$NAME) and replaces them 
with a different string. 

%--------------------------------------------------------------------------
\subsection{\label{A:Comp_Env:Remote}Working on Remote Resources}
%--------------------------------------------------------------------------

At some point during research you will need to execute code on remote 
resources that are typically large computing clusters ($> 100$ central 
processing units). 
You will be provided with a terminal session similar to the session 
provided by Ubuntu with most of the same system commands. 
While I recommend 
\href{https://filezilla-project.org/}{Filezilla} 
for handling the transfer of data and files, 
the functionality of Filezilla is contained in several shell 
commands: ssh and scp. 
Files can be transferred using the following command
\begin{lstlisting}
$ scp -r user@gilgamesh.cheme.cmu.edu:/home/user/directory/ ./
\end{lstlisting}
which will place the ``directory'' and its contents into the pwd 
(./) of the local terminal session. 

There are many variants of the operating systems used for remote 
computing clusters, but the differences are usually small. 
During my work I regularly used the 
\href{http://gilgamesh.cheme.cmu.edu/doc/gilgamesh.html}
{gilgamesh} computing cluster maintained by 
\href{https://github.com/jkitchin}{John Kitchin}. 
\href{http://gilgamesh.cheme.cmu.edu/doc/gilgamesh.html}
{Gilgamesh's documentation} is a good resource for learning how to run 
calculations on a computing cluster.

%--------------------------------------------------------------------------
\section{\label{A:Comp_Env:Programs}
Installing, Writing and Executing Programs}
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
\subsection{\label{A:Comp_Env:Install}Installing Available Packages}
%--------------------------------------------------------------------------

Before writing any of your own code, it is best to use any useful 
code that may already exist. 
Most Linux operating systems have automatic software installation. 
For Ubuntu, program  management is achieved using the 
\href{https://help.ubuntu.com/community/AptGet/Howto}{apt-get} 
system command:

\begin{lstlisting}
$ sudo apt-get install gfortran
[sudo] password for jason: 
Reading package lists... Done
...
\end{lstlisting}
To check that the package has been installed, use:
\begin{lstlisting}
$ which gfortran
/usr/bin/gfortran
\end{lstlisting}
This shows that gfortran program is installed in the /usr/bin/ folder, 
a common location where automatically installed programs are located. 
Because the 
folder /usr/bin is in the PATH environment variable, 
the program gfortran is always available no matter where you are in 
the system terminal. 

To get more information about the gfortran, use:
\begin{lstlisting}
$ ls -l /usr/bin/gfortran
lrwxrwxrwx 1 root root 12 Apr 22 03:44 /usr/bin/gfortran -> gfortran-4.7
\end{lstlisting}
where we see that /usr/bin/gfrotran "points" to gfortran-4.7. 
This is called a 
\href{http://en.wikipedia.org/wiki/Symbolic_link}{symbolic link}.

%--------------------------------------------------------------------------
\subsection{\label{A:Comp_Env:Avail}Available Packages for 
Thermal Transport Modeling}
%--------------------------------------------------------------------------

Available programs represent opportunities to perform research quickly 
and easily. I suggest reading their documentation carefully and trying 
the tutorials and examples, which are typically computationally 
inexpensive. 

Most of the existing packages listed below cannot be installed using 
Ubuntu's apt-get command, although 
\href{http://lammps.sandia.gov/download.html#ubuntu}
{this feature does exist for LAMMPS} and more packages are likely 
to be added in the future. It is important to read the installation 
documentation carefully. It is also helpful to contact any system 
Linux/Unix system administration staff or other researchers who are 
experienced with installing packages. These people can usually be 
found at campus or local computing centers, or in your own 
research group! 

For a first-time user, I recommend trying to install the LAMMPS 
package as it is one of the easiest and most versatile. It has 
standard installation files for systems ranging from your 
personal computer up to a massively-parallel supercomputer. 
Installation instructions can be 
\href{http://lammps.sandia.gov/doc/Section_start.html#start_2}{found here}. 

Here is a partial list of the packages I have found useful 
in this work:

\begin{itemize}
\item \href{http://lammps.sandia.gov/}{LAMMPS}, including the particularly 
useful 
\href{http://lammps.sandia.gov/threads/threads.html}{mailing list} 
and
\href{http://lammps.sandia.gov/doc/Section_python.html}
{python interface}: parallel molecular dynamics using empirical interatomic 
potentials.
\item \href{http://www.stfc.ac.uk/CSE/randd/ccg/software/DL_POLY/25526.aspx}
{DL$\_$POLY}: parallel molecular dynamics using empirical interatomic 
potentials.
\item \href{http://projects.ivec.org/gulp/}{GULP}: harmonic lattice 
dynamics using empirical interatomic potentials. 
\item \href{http://phonopy.sourceforge.net/}{phonopy}: harmonic 
lattice dynamics with interface for $\emph{ab initio}$ package. 
\item \href{http://www.homepages.ucl.ac.uk/~ucfbdxa/phon/}{PHON}: 
harmonic lattice dynamics with interface for $\emph{ab initio}$ package.
\item \href{http://www.abinit.org/}{ABINIT}: $\emph{ab initio}$ package. 
\item \href{http://www.quantum-espresso.org/}{Quantum Espresso}: 
$\emph{ab initio}$ package. 
\item \href{https://www.vasp.at/}{VASP}: $\emph{ab initio}$ package. 
\item \href{http://icmab.cat/leem/siesta/}{SIESTA}: 
$\emph{ab initio}$ package. 
\item \href{http://www.msg.ameslab.gov/gamess/}{GAMESS}: 
$\emph{ab initio}$ package.
\item \href{http://www.cp2k.org/}{CP2K}: 
$\emph{ab initio}$ package.
\item \href{http://www.icams.de/content/departments/ams/madsen/boltztrap.html}{BOLTZTRAP} 
\item \href{http://www.ks.uiuc.edu/Research/vmd/}{VMD} 
(with 
\href{https://sites.google.com/site/akohlmey/software/topotools}
{topotools}): structure and visualization. 
\item \href{http://jp-minerals.org/vesta/en/}{VESTA}: structure and 
visualization. 
\end{itemize}

I recommend trying this 
\href{https://gist.github.com/kparrish/6064159}{install.sh} created by 
\href{http://www.github.com/kparrish}{Kevin Parrish} which installs 
many programs and packages, including LAMMPS for parallel computing 
with 
\href{http://www.open-mpi.org/}{OpenMPI}.

%--------------------------------------------------------------------------
\subsection{\label{A:Comp_Env:Writing}Writing Programs: 
Compiled versus Interpreted}
%--------------------------------------------------------------------------

If no package exists to perform the calculation you are interested in, 
there is a good chance you are doing something interesting! The next 
step is to implement the algorithm for the calculation you want 
to perform. There are two choices for doing this: 
\begin{itemize}
\item Write your own code. 
\item Build off an existing package. 
\end{itemize}

As outlined in the previous 
section, there are many pre-existing packages with many functionalities. 
The many packages that can perform nanoscale transport calculations use 
\href{http://en.wikipedia.org/wiki/Compiled_language}{compiled} and 
\href{http://en.wikipedia.org/wiki/Interpreted_language}{interpreted}  
languages, often with a mixture of the two. 
The most commonly used compiled languages are 
\href{https://en.wikipedia.org/wiki/C\%2B\%2B}{C/C++} 
(e.g., Linux, LAMMPS) 
and 
\href{http://en.wikipedia.org/wiki/Fortran}{Fortran}
(e.g., GULP, Quantum Espresso, VASP). 
Here is a good discussion on 
\href{http://stackoverflow.com/questions/13078736/fortran-vs-c-does-fortran-still-hold-any-advantage-in-numerical-analysis-thes}
{the strengths of C++ versus Fortran}. Here are excellent tutorials 
of programming in  
\href{http://www.youtube.com/watch?v=XFQ9dw3CyDo&list=PL1D10C030FDCE7CE0}
{C++}
and 
\href{http://www.youtube.com/watch?v=YRTEOFMUTzw&list=PL6A8E21D2E86A0155}
{Fortran}. Learning these languages is essential to adding to existing 
packages. 

Interpreted languages allow for fast code development and debugging. 
The two interpreted languages you are likely to use are 
\href{http://en.wikipedia.org/wiki/MATLAB}{Matlab}  
and 
\href{http://en.wikipedia.org/wiki/Python_(programming_language)}{Python}. 
The key to maximizing the potential of interpreted languages is by 
using the built-in ``vector'' functions and operations provided by the 
\href{http://www.mathworks.com/help/matlab/matlab_prog/vectorization.html}
{Matlab}  
and 
\href{http://faculty.washington.edu/rjl/uwamath583s11/sphinx/notes/html/python_vect.html}
{Python}  
programming libraries. 
Matlab has an excellent built-in guide and google searches will typically 
yield useful results. An open-source substitute for Matlab is 
\href{http://www.gnu.org/software/octave/}
{Octave}, which is capable to running most Matlab scripts.

The following three case studies are performed on my local 
\href{http://www.samsung.com/us/computer/series-9-notebooks}
{Samsung series 9 notebook}. The 
specifications of the computer can be accessed by using:
\begin{lstlisting}
$ cat /proc/cpuinfo 
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 58
model name	: Intel(R) Core(TM) i5-3317U CPU @ 1.70GHz
stepping	: 9
microcode	: 0x17
cpu MHz		: 782.000
cache size	: 3072 KB
physical id	: 0
siblings	: 4
core id		: 0
cpu cores	: 2
apicid		: 0
initial apicid	: 0
\end{lstlisting}

%--------------------------------------------------------------------------
\subsubsection{\label{A:coding_lang:case1}Case-study (a): 
Optimizing Compiled Codes}
%--------------------------------------------------------------------------

The first case study is a 
\href{https://github.com/jasonlarkin/disorder/tree/master/md_serial}
{single C code to perform molecular dynamics 
on LJ argon}. The code uses simple subroutines and operates using 
a single (serial) processor. The 
\href{http://www.cplusplus.com/doc/tutorial/arrays/}
{arrays in this code are built statically}. 
Arrays can be created 
\href{http://www.cplusplus.com/doc/tutorial/dynamic/}{dynamically}, 
which allows for the input of systems with varying number of 
atoms. Additionally, 
\href{http://www.cplusplus.com/reference/vector/vector/}{vectors} 
can be created and destroyed dynamically and have some advantages 
over arrays.  

The code is compiled using the 
\href{http://www.gnu.org/}{GNU project's} 
C++ compiler, \href{http://www.cprogramming.com/g++.html}{g++}:
\begin{lstlisting}
$ g++ ArgonMD.cpp -o ArgonMD_O_g++
\end{lstlisting}
The code can be run and the output can be directed using a useful 
shell operation called 
\href{http://www.linfo.org/pipes.html}{piping}, 
which is demonstrated below:
\begin{lstlisting}
$ ArgonMD_O_g++ > ./ArgonMD_O/output.txt
\end{lstlisting}
The code can be compiled using 
\href{http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options}
{optimization flags, such as -O and -O3}:
\begin{lstlisting}
$ g++ -O3 ArgonMD.cpp -o ArgonMD_O3_g++
\end{lstlisting}
which greatly decreases the run time of this particular code. 
The total run time 
can displayed by using the shell command 
\href{http://linux.about.com/od/commands/l/blcmdl1_grep.htm}{grep},  
which shows for no optimization:
\begin{lstlisting}
$ grep -A 1 "Total Time" ./ArgonMD/output.txt
Total Time: 38.42 (s)
\end{lstlisting}
for -O optimization:
\begin{lstlisting}
$ grep -A 1 "Total Time" ./ArgonMD_O/output.txt
Total Time: 18.06 (s)
\end{lstlisting}
and for -O3 optimization:
\begin{lstlisting}
$ grep -A 1 "Total Time" ./ArgonMD_O3/output.txt
Total Time: 11.74 (s)
\end{lstlisting}
A useful shell command is 
\href{http://www.tuxfiles.org/linuxhelp/vimcheat.html}{vi}, a 
shell-based text editor, which can display the output within 
a shell terminal:
\begin{lstlisting}
$ vi ./ArgonMD/output.txt
0       1       5.61358 2.01864 5.26596
...
\end{lstlisting}

To compare with the above results, the LAMMPS code is compiled in serial 
using no , -O, and -O3 optimizations.  
The results are contained in folders beginning with ``lmp''.  A useful 
shell function is 
\href{http://www.tuxfiles.org/linuxhelp/tabtrick.html}{tab-twice}, 
where tapping the tab key twice 
will display files and folders which begin with the same 
characters:
\begin{lstlisting}
$ grep -A 1 "Loop time" ./lmp
lmp.in.lj~     lmp_serial/    lmp_serial_O/  lmp_serial_O3/
\end{lstlisting}
The tab key can also be used for  
\href{http://en.wikipedia.org/wiki/Command-line_completion}
{command-line completion} to complete directory and file names. The run 
time for no optimization is:
\begin{lstlisting}
$ grep -A 1 "Loop time" ./lmp_serial/log.lammps
Loop time of 0.718188 on 1 procs for 1000 steps with 256 atoms
--
Loop time of 3.4892 on 1 procs for 5000 steps with 256 atoms
\end{lstlisting}
for -O optimization:
\begin{lstlisting}
$ grep -A 1 "Loop time" ./lmp_serial_O/log.lammps
Loop time of 0.19842 on 1 procs for 1000 steps with 256 atoms
--
Loop time of 0.917175 on 1 procs for 5000 steps with 256 atoms
\end{lstlisting}
and for -O3 optimization:
\begin{lstlisting}
$ grep -A 1 "Loop time" ./lmp_serial_O3/log.lammps
Loop time of 0.164066 on 1 procs for 1000 steps with 256 atoms
--
Loop time of 0.786311 on 1 procs for 5000 steps with 256 atoms
\end{lstlisting}

There is a decrease in run time with increasing optimization 
for LAMMPS and my code. However, for every 
optimization the LAMMPS code is approximately an order of 
magnitude faster.  This result is 
due to a several factors, the most important being 
the implementation of 
\href{http://en.wikipedia.org/wiki/Neighbor_list}{neighbor lists} 
as discussed in the 
\href{http://lammps.sandia.gov/doc/neighbor.html}
{LAMMPS documentation}. The interested reader is encouraged to 
investigate the LAMMPS code further for useful C++ coding 
practices. 

%--------------------------------------------------------------------------
\subsubsection{\label{A:coding_lang:case2}
Case-study (b): Computational Cost of Interpreted Code}
%--------------------------------------------------------------------------

With interpreted languages, the traditional programming practice of using 
loops (for/do/while, etc) will slow the code execution.  To illustrate 
this behavior, the case study compares codes to perform harmonic lattice 
dynamics calculations. 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/m_lj_ld_prim.m}
{One code is written in Matlab} using mixture of loops 
and vectorized functions, which slows the code execution. The other 
code is written in Fortran (i.e., the GULP package). 

From within a Matlab session in a terminal, the Matlab code can be 
executed as follows:
\begin{lstlisting}
tic
[freq,eigVsorted,velocity] = m_lj_ld_prim(1.5636*[1 1 1],[0.5 0.0 0.0])
toc
Elapsed time is 0.047081 seconds.
\end{lstlisting}
for the 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/m_lj_ld_prim.m}
{primitive}, and
\begin{lstlisting}
tic
[freq,eigVsorted,velocity] = m_lj_ld_conv(1.5636*[1 1 1],[0.5 0.0 0.0])
toc
Elapsed time is 0.260508 seconds.
\end{lstlisting}
for the 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/m_lj_ld_conv.m}
{conventional} unit cells. Note that the increased run time is not 
proportional to the increased number of atoms in the unit cell (i.e., 
the calculation does not scale linearly). 
Also note that the two codes both use for loops. This usage slows down code 
execution because Matlab is an interpreted language. 

Now we run the same calculation using the Fortran-based GULP package, for 
the 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/gulp_disp_lj_prim.gin}
{primitive}:
\begin{lstlisting}
$ grep -A 6 "Timing analysis " gulp_disp_lj_prim.gout
  Timing analysis for GULP :

---------------------------------------------------------------------------
  Task / Subroutine                                          Time (Seconds)
---------------------------------------------------------------------------
---------------------------------------------------------------------------
  Total CPU time                                                  0.0030
\end{lstlisting}
and 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/gulp_disp_lj_conv.gin}
{conventional} unit cells:
\begin{lstlisting}
$ grep -A 6 "Timing analysis " gulp_disp_lj_conv.gout
  Timing analysis for GULP :
---------------------------------------------------------------------------
  Task / Subroutine                                          Time (Seconds)
---------------------------------------------------------------------------
---------------------------------------------------------------------------
  Total CPU time                                                  0.0160
\end{lstlisting}

First, the scaling of the calculation is non-linear. Second, the timing for 
both calculations is over an order of magnitude less than the Matlab versions. 
Matlab code can be optimized by using the built in vector operations and 
functions, which is demonstrated in the next section.

%--------------------------------------------------------------------------
\subsubsection{\label{A:coding_lang:case3}
Case-study (c): Optimizing Interpreted Code}
%--------------------------------------------------------------------------

This case study demonstrates that Matlab (or other interpreted languages) 
can be optimized using the built-in vector functions and operations. 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/m_af_template.m}
{This Matlab code} performs the AF theory calculations 
on a LJ amorphous phase of 256 atoms. The code can be run from within 
a Matlab terminal using:
\begin{lstlisting}
>> m_af_template
ans =
    1.5075 (s)
\end{lstlisting}
which calls several subroutines, most notably 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/m_af_lj.m}{m$\_$af$\_$lj.m}, 
which uses all vectorized functions. 

Comparing this result with the 
\href{https://github.com/jasonlarkin/disorder/blob/master/matlab/gulp/x0_256.gin}
{same calculation in GULP}:
\begin{lstlisting}
$ gulp x0_256
$ grep -A 10 "Timing analysis " x0_256.gout
  Timing analysis for GULP :
---------------------------------------------------------------------------
  Task / Subroutine                                          Time (Seconds)
---------------------------------------------------------------------------
  Calculation of real space energy and derivatives                0.0520
  Calculation of phonons                                         18.5720
  Calculation of scattering                                       0.0000
---------------------------------------------------------------------------
  Total CPU time                                                 19.3920
---------------------------------------------------------------------------
\end{lstlisting}
The relevant subroutine in GULP to compare with the Matlab version is 
thermalconductivity.f90. 
The GULP timing is considerably larger than the Matlab code.  This is 
due to the use of the default unoptimized 
\href{http://www.netlib.org/blas/}{BLAS} and 
\href{http://www.netlib.org/lapack/}{LAPACK} libraries 
for linear algebra that were used to compile GULP. During the installation, 
Matlab optimizes its linear algebra library, resulting 
in improved performance. 
\nomenclature[A]{BLAS}{Basic Linear Algebra Subprograms} 
\nomenclature[A]{LAPACK}{Linear Algebra PACkage} 

% %--------------------------------------------------------------------------
% \subsection{\label{A:coding_lang:Execute}Executing Programs}
% %--------------------------------------------------------------------------
% 
% %--------------------------------------------------------------------------
% \subsubsection{\label{A:coding_lang:Execute:Local}
% Executing Locally: Rapid Development}
% %--------------------------------------------------------------------------
% 
% %--------------------------------------------------------------------------
% \subsubsection{\label{A:coding_lang:Execute:Remote}
% Executing Remotely: Portable Batch Systems}
% %--------------------------------------------------------------------------

%--------------------------------------------------------------------------
\subsection{\label{A:coding_lang:Execute:Scaling}
Scaling Calculations}
%--------------------------------------------------------------------------

The majority of the methods 
used in this work scale poorly with the number of atoms, $N_a^\alpha$, 
with $\alpha >1$. 
The scaling cost for eigenvalue solution is $N_a^3$. 
The cost of performing this calculation for the largest system size,  
$cost_{large}$,  
and every successive system which is half the size of the largest 
is given by the 
\href{http://en.wikipedia.org/wiki/Geometric_series}{geometric series} 
with common ratio $r=1/8$
\begin{equation}\label{EQ:cost_total}
\begin{split}
cost_{total} = cost_{large}\frac{1}{1-r} = 1.143N_{a,large}. 
\end{split}
\end{equation}
It costs a minimal amount ($ \approx 14\%$) to study every system that 
is smaller 
than the largest system considered. Even a linear scaling   
has (with $r=1/2$) a total cost $cost_{total} = 2cost_{large}$. 
As such, I recommend starting calculations with 
the smallest system of interest (i.e., the 
\href{http://meta.tex.stackexchange.com/questions/3300/minimum-working-example-mwe}
{Minimum Working Example} method). 
Journal article draft manuscripts can be 
developed quickly by performing computationally-inexpensive 
calculations first, documenting the results, and then iterating to more 
computationally-expensive calculations. 
This scheme for performing calculations can follow these time-scales 
for calculation costs:
\begin{itemize}
\item 1 second: exploratory work, debugging.  
\item 1 minute/1 hour: testing the scaling of algorithms, precision  
\item 1 day: publication-quality calculations
\item 1 week: publication-quality calculations, but should be limited 
to when necessary. 
\end{itemize}
I have performed 
countless calculations costing around one second, and very few which cost 
more than one week. Publication quality results will typically 
cost between one hour and one week.
\nomenclature[V]{$cost_{total}$}{total computational cost} 

%--------------------------------------------------------------------------


%%--------------------------------------------------------------------------
%\subsection{Importance of Open-Source Code}
%%--------------------------------------------------------------------------

%LAMMPS Mailing List
%http://lammps.sandia.gov/threads/threads.html

%search: 

%lennard (jones)	45
%silicon		125
%nanotube	153
%ger


%Execellent discussion of ensembles and newtonian dynamics
%http://lammps.sandia.gov/threads/msg13979.htmlmanium	2
%silica		79
%carbon		181
%hydrogen	99
%fullerene(C60)	7(12)	
%Pb (lead)	2
%water		541
%copper(cu)	25
%gold		81
%diamond		43

%phase transition	21
%green kubo	18


%Execellent discussion of ensembles and newtonian dynamics
%http://lammps.sandia.gov/threads/msg13979.html

%video of python development tree

%\href{http://www.youtube.com/watch?v=3poNeQHUKrs}
%{google+ history with gource}

%\href{http://www.youtube.com/watch?v=cNBtDstOTmA}
%{python history with gource}

%grand-daddy of them all, 
%\href{http://www.youtube.com/watch?v=pOSqctHH9vY}
%{linux kernel history with gource}

%It is important that results become more open-source.  It's important 
%that our communication becomes open-source. It's important that the 
%entire numerical process be carried out open-source. 


%%--------------------------------------------------------------------------
%\subsection{Redundancy}
%%--------------------------------------------------------------------------
%
%There are 3 different codes (shiomi/esfarjani, broido, ankit) for 
%performing the same basic calculations.
%
%For LD, there is GULP, phonopy, SIESTA, etc.
%
%%--------------------------------------------------------------------------
%\subsection{Code Development}
%%--------------------------------------------------------------------------
%
%took ankit 10 months to re-develop esfarjani code.  
%
%code development time can be drastically reduced using pre-existing code. 
%codes written in a modular fashion can be added to easily.
%
%%--------------------------------------------------------------------------
%\subsection{Experiment Pre-dating Simulation}
%%--------------------------------------------------------------------------
%The ideal goal of simulation is to pre-date experiment.  This has not 
%been achieved yet.  See Fig.
%
%findings for:
%CNT/Graphene
%Si
%Thermoeletric (LUC, alloys, SL, etc)
%Perovskites
%PCM
%
%%--------------------------------------------------------------------------
%\subsection{Experiment Pre-dating Simulation}
%%--------------------------------------------------------------------------
%
%ntpl most cited paper 1-5:
%maradudin, ladd, dove, ziman, 

%--------------------------------------------------------------------------
\section{Preparing Journal Articles and Thesis}
%--------------------------------------------------------------------------

The job of the student is to prepare, submit, and publish 
peer-reviewed journal articles. There are many journals suitable for 
nanoscale transport topics. All of them accept 
\href{http://www.latex-project.org/}{Latex} prepared manuscripts. 
I recommend the Latex editor 
\href{http://kile.sourceforge.net/}{Kile}, while the simple 
\href{https://projects.gnome.org/gedit/}{gedit} works well and comes 
pre-installed with Ubuntu. Here is a 
\href{http://mally.stanford.edu/~sr/computing/latex-example.html}
{simple latex example} and how to generate a 
\href{http://tex.stackexchange.com/questions/1596/how-to-compile-a-latex-document}
{portable document format (PDF)} from the latex document.  

I recommend editing a written research document at least once every week. 
The exchange of such a document with the advisor can be facilitated using 
\href{https://www.dropbox.com/}{Dropbox} or 
\href{https://github.com/}{Github}. 
Github offers advantages over Dropbox, such as version control and a 
\href{https://github.com/ntpl/ntpy/wiki}{built-in online wiki}. 
Such a research document can turn into journal articles, 
which then turn into the thesis.  

To maintain the reference library I 
recommend 
\href{http://www.zotero.org/}{zotero}.  Here is an example 
\href{https://github.com/jasonlarkin/disorder/blob/master/paper/vc/jap/ntpl-032013.bib}
{reference.bib} 
file which is exported automatically by zotero. 
The references are generated from the latex document using 
\href{http://www.bibtex.org/Using/}{bibtex}, which compiles the contents of 
the reference.bib.

\href{https://github.com/jasonlarkin/disorder/blob/master/paper/vc/jap/jap_vc_jl_060413.tex}
{Here is an example} of the latex file 
used to create an article published from this work. 
This file uses 
\href{http://publish.aps.org/revtex}{revtex}, 
which is an article class used by $\emph{Physical Review}$, 
$\emph{Journal of Applied Physics}$, and others.
\href{https://github.com/robsimmons/cmu-thesis}
{Here is a Carnegie Mellon thesis template}, 
which was used to create 
\href{https://github.com/jasonlarkin/thesis/tree/master/thesis}
{this thesis document}.

% \href{http://web.science.mq.edu.au/~rdale/resources/writingnotes/latexstruct.html}
% {Article on structuring large documents.}
% %--------------------------------------------------------------------------
% \subsection{Producing Figures}
% %--------------------------------------------------------------------------
% 
% Python has a plotting module, \href{http://matplotlib.org/}{matplotlib}, 
% which has \href{http://matplotlib.org/examples/index.html}{many examples}. 
% Here is a \href{https://gist.github.com/kparrish/6101681}{simple example 
% demonstrating how to generate and save data, load that data, and plot.} 
% 
% 
% \href{https://github.com/ntpl/ntpy/tree/master/examples/thesis}
% {Here is a simple example demonstrating how to }

%--------------------------------------------------------------------------
\section{Technical Advice}
%--------------------------------------------------------------------------

In addition to your advisor and close mentors, 
I recommend communicating with experts in the field as much as 
possible (without being annoying).  How often to 
communicate depends on the situation. 
It is best to let the expert dictate the pace of the conversation. 
Here is a list of experts I used as resources for this work. They 
will typically answer emails within 24-48 hours:

\begin{itemize}
\item \href{http://www.engineering.pitt.edu/WissamAlSaidi/}
{Wissam Al-Saidi}
\item \href{http://www2.mpip-mainz.mpg.de/~donadio/tnt/People.html}
{Davide Donadio}
\item \href{http://johncduda.com/}
{John Duda}
\item \href{http://mech.rutgers.edu/content/keivan-esfarjani}
{Keivan Esfarjani}
\item \href{mailto:joseph.feldman.ctr@nrl.navy.mil}
{Joseph Feldman}
\item \href{http://chemistry.curtin.edu.au/people/academic.cfm/J.Gale}
{Julian Gale}, \href{http://projects.ivec.org/gulp/news.html}
{(GULP author)}
\item \href{http://quasiamore.mit.edu/pmwiki.php?n=Main.JivteshGarg}
{Jivtesh Garg}
\item \href{https://github.com/ankitjainmeiitk}
{Ankit Jain}
\item \href{https://github.com/jkitchin}
{John Kitchin}
\item Axel Kolhmeyer via the 
\href{http://lammps.sandia.gov/threads/threads.html}{LAMMPS mailing list} 
and \href{akohlmey@gmail.com}{email}
\item \href{http://jasonlarkin.github.io}{Jason Larkin}
\item \href{http://www.cmu.edu/me/malen/Lab_Website/People.html}
{Jon Malen}
\item \href{http://www.ce.cmu.edu/people/faculty/maloney.html}
{Craig Maloney}
\item \href{http://ntpl.me.cmu.edu/people.html}
{Alan McGaughey}
\item \href{http://www.pmc.umontreal.ca/~mousseau/site_an/}
{Normand Mousseau}
\item Steve Plimpton via the 
\href{http://lammps.sandia.gov/threads/threads.html}{LAMMPS mailing list} 
\item \href{http://www.chem.polimi.it/people/faculty/guido-raos/}
{Guido Raos}
\item \href{http://utexas.academia.edu/DanSellan}
{Dan Sellan}
\item \href{http://www.phonon.t.u-tokyo.ac.jp/}
{Junchiro Shiomi}
\item \href{http://atztogo.users.sourceforge.net/}{Atz Togo}, creator of 
\href{http://phonopy.sourceforge.net/}{phonopy}
\end{itemize}
